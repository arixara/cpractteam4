#define _CRT_SECURE_NO_WARNINGS
#include "Header.h"
#include <iostream>
#include <iomanip>
#include <cstdlib>
#include <time.h>
#include <fstream>
#include <string>
#include <vector>
#include <queue>
#include <utility>

using namespace std; // мб поменять


const int INF = 10e6; // Максимальный вес ребра в графе

// ВАЖНО: Дейкстра написан на списках смежности
// s --- вершина, откуда идем
// v --- вершина, длину кратчайшего пути до которой ищем

int dijkstra(const vector<vector<int> >& g, int s, int v) { // Мацулевич Валерий
	// Вектор кратчайших расстояний от s до всех остальных вершин в графе
	vector<int> d(g.size(), INF);

	// По дефолту расстояние от s до s равно нулю
	d[s] = 0;

	// Заводим очередь вершин, которые будем перебирать
	// Элемент очереди --- вершина и расстояние до нее
	priority_queue<pair<int, int> > q;

	// Добавляем туда исходную вершину
	q.emplace(0, s);

	// Пока можем куда-то сходить
	while (!q.empty()) {
		// Достанем расстояние до следующей вершины
		int len = -q.top().first;
		// Достанем ее номер
		int u = q.top().second;
		// Удалим вершину из очереди
		q.pop();

		// Если известное минимальное расстояние до этой вершины меньше, чем len
		if (d[u] <= len) {
			// Переберем все пути из этой вершины до остальных
			for (int i = 0; i < g.size(); ++i) {
				int dist = g[u][i]; // Возьмем расстояние от этой вершины до i-ой
				// Если оно положительное и минимальное расстояние до i-ой вершины больше, чем минимальное расстояние до u +dist
				if (dist > 0 && d[i] > d[u] + dist) {
					// Обновим это минимальное расстояние
					d[i] = d[u] + dist;

					// Будем потом искать пути из этой вершины
					q.emplace(-d[i], i);
				}
			}
		}
	}

	// Если вершина лежит в другой компоненте связности вернем отрицательное расстояние
	if (d[v] == INF) return -1;

	// Иначе вернем расстояние до нее
	return d[v];
}

int reading(int numb) { //функция чтения файла и записи в массив
	std:: fstream file;
	int size;
	string way = to_string(numb) + ".txt";
	
	file.open(way, ios::in); //открыть на чтение файл заданного номера с данными

	file.getline(size); //считать размер



	//выделение памяти

	int time; // счетчик времени
	clock_t t;
	t = clock();

	// выбор алгоритма задачи

	time = clock() - t;
	file.close(); // закрыть файл после прочтения
	return time;

	file.close(); // закрыть файл после прочтения
	return time;
}